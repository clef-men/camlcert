From simuliris Require Import
  prelude.
From simuliris.program_logic Require Import
  sim.adequacy.
From simuliris.tmc_lang Require Import
  refinement
  subexpr.
From simuliris.tmc Require Export
  definition.
From simuliris.tmc Require Import
  properties
  sim.proofmode
  csim.rules
  csim.notations.

Section sim_GS.
  Context `{sim_programs : !SimPrograms tmc_ectx_lang tmc_ectx_lang}.
  Context `{sim_GS : !SimGS Œ£}.
  Context (tmc : tmc sim_prog‚Çõ sim_prog‚Çú).
  Implicit Types func func_dps : function.
  Implicit Types idx idx‚Çõ idx‚Çú : index.
  Implicit Types l l‚Çõ l‚Çú dst : loc.
  Implicit Types v v‚Çõ v‚Çú : val.
  Implicit Types e e‚Çõ e‚Çú : expr.
  Implicit Types Œ¶ : val ‚Üí val ‚Üí iProp Œ£.
  Implicit Types Œ® : expr ‚Üí expr ‚Üí iProp Œ£.

  Definition tmc_protocol_dir Œ® e‚Çõ e‚Çú : iProp Œ£ :=
    ‚àÉ func v‚Çõ v‚Çú,
    ‚åúfunc ‚àà dom sim_prog‚Çõ‚åù ‚àó
    ‚åúe‚Çõ = func v‚Çõ ‚àß e‚Çú = func v‚Çú‚åù ‚àó
    v‚Çõ ‚âà v‚Çú ‚àó
    (‚àÄ v‚Çõ' v‚Çú', v‚Çõ' ‚âà v‚Çú' -‚àó Œ® v‚Çõ' v‚Çú').
  Definition tmc_protocol_dps Œ® e‚Çõ e‚Çú : iProp Œ£ :=
    ‚àÉ func func_dps v‚Çõ l1 l2 dst idx v‚Çú,
    ‚åúfunc ‚àà dom sim_prog‚Çõ ‚àß tmc.(tmc_Œæ) !! func = Some func_dps‚åù ‚àó
    ‚åúe‚Çõ = func v‚Çõ ‚àß e‚Çú = func_dps l1‚åù ‚àó
    (l1 +‚Çó 1) ‚Ü¶‚Çú l2 ‚àó (l1 +‚Çó 2) ‚Ü¶‚Çú v‚Çú ‚àó
    (l2 +‚Çó 1) ‚Ü¶‚Çú dst ‚àó (l2 +‚Çó 2) ‚Ü¶‚Çú idx ‚àó
    (dst +‚Çó idx) ‚Ü¶‚Çú () ‚àó
    v‚Çõ ‚âà v‚Çú ‚àó
    (‚àÄ v‚Çõ' v‚Çú', (dst +‚Çó idx) ‚Ü¶‚Çú v‚Çú' -‚àó v‚Çõ' ‚âà v‚Çú' -‚àó Œ® v‚Çõ' #()).
  Definition tmc_protocol Œ® e‚Çõ e‚Çú : iProp Œ£ :=
    tmc_protocol_dir Œ® e‚Çõ e‚Çú ‚à®
    tmc_protocol_dps Œ® e‚Çõ e‚Çú.

  Lemma tmc_protocol_dps' func v‚Çõ func_dps dst idx v‚Çú Œ¶ :
    func ‚àà dom sim_prog‚Çõ ‚Üí
    tmc.(tmc_Œæ) !! func = Some func_dps ‚Üí
    (dst +‚Çó idx) ‚Ü¶‚Çú () -‚àó
    v‚Çõ ‚âà v‚Çú -‚àó
    (‚àÄ v‚Çõ' v‚Çú', (dst +‚Çó idx) ‚Ü¶‚Çú v‚Çú' -‚àó v‚Çõ' ‚âà v‚Çú' -‚àó Œ¶ v‚Çõ' ()%V) -‚àó
    SIM func v‚Çõ ‚â≥ func_dps (dst, idx, v‚Çú) [[ tmc_protocol ]] [[ Œ¶ ]].
  Proof.
    iIntros "%Hfunc‚Çõ %HŒæ Hdst #Hv HŒ¶".
    sim_constr‚Çú; sim_constr‚Çú;
      sim_constr_det‚Çú as l2 "Hl20" "Hl21" "Hl22";
      sim_constr_det‚Çú as l1 "Hl10" "Hl11" "Hl12";
      sim_apply (simv_apply_protocol _ (sim_post_val Œ¶) (func v‚Çõ) (func_dps l1)); iIntros "%œÉ‚Çõ %œÉ‚Çú $ !>";
      ( iSplitL;
        [ iRight; iExists func, func_dps, v‚Çõ, l1, l2, dst, idx, v‚Çú; iFrame "#‚àó";
          do 2 (iSplit; first done); iIntros "%v‚Çõ' %v‚Çú' Hdst #Hv'";
          iExists v‚Çõ', ()%V; iSplit; first done;
          iApply ("HŒ¶" with "Hdst Hv'")
        | iIntros "% % (%v‚Çõ' & %v‚Çú' & (-> & ->) & HŒ¶)";
          sim_post
        ]
      ).
  Qed.

  Definition tmc_dir_post :=
    (‚âà)%I.
  Definition tmc_dps_post dst idx v‚Çõ v‚Çú : iProp Œ£ :=
    ‚àÉ v‚Çú',
    ‚åúv‚Çú = ()%V‚åù ‚àó (dst +‚Çó idx) ‚Ü¶‚Çú v‚Çú' ‚àó v‚Çõ ‚âà v‚Çú'.

  Definition tmc_dir_spec' e‚Çõ e‚Çú :=
    expr_well_formed sim_prog‚Çõ e‚Çõ ‚Üí
    [[[ True ]]] e‚Çõ ‚©æ e‚Çú [[ tmc_protocol ]] [[[ tmc_dir_post ]]].
  Definition tmc_dir_spec e‚Çõ e‚Çú :=
    tmc_dir tmc.(tmc_Œæ) e‚Çõ e‚Çú ‚Üí
    tmc_dir_spec' e‚Çõ e‚Çú.
  Definition tmc_dps_spec' dst idx e‚Çõ e‚Çú :=
    expr_well_formed sim_prog‚Çõ e‚Çõ ‚Üí
    [[[ (dst +‚Çó idx) ‚Ü¶‚Çú () ]]] e‚Çõ ‚©æ e‚Çú [[ tmc_protocol ]] [[[ tmc_dps_post dst idx ]]].
  Definition tmc_dps_spec dst idx e‚Çõ e‚Çú :=
    tmc_dps tmc.(tmc_Œæ) dst idx e‚Çõ e‚Çú ‚Üí
    tmc_dps_spec' dst idx e‚Çõ e‚Çú.
  Definition tmc_spec e‚Çõ e‚Çú :=
    tmc_dir_spec e‚Çõ e‚Çú ‚àß
    ‚àÄ dst idx, tmc_dps_spec dst idx e‚Çõ e‚Çú.

  Lemma tmc_specification e‚Çõ e‚Çú :
    tmc_spec e‚Çõ e‚Çú.
  Proof.
    revert e‚Çú. induction e‚Çõ as [e‚Çõ IHe‚Çõ] using (well_founded_ind subexpr_wf).
    cut (
      ( ‚àÄ e‚Çõ e‚Çú,
        tmc_dir tmc.(tmc_Œæ) e‚Çõ e‚Çú ‚Üí
        (‚àÄ e‚Çõ' e‚Çú', e‚Çõ' ‚äè e‚Çõ ‚Üí tmc_dir_spec e‚Çõ' e‚Çú') ‚Üí
        (‚àÄ dst idx e‚Çõ' e‚Çú', e‚Çõ' ‚äè e‚Çõ ‚Üí tmc_dps_spec dst idx e‚Çõ' e‚Çú') ‚Üí
        tmc_dir_spec' e‚Çõ e‚Çú
      ) ‚àß (
        ‚àÄ (dst idx : expr) e‚Çõ e‚Çú,
        tmc_dps tmc.(tmc_Œæ) dst idx e‚Çõ e‚Çú ‚Üí
        (‚àÄ e‚Çõ' e‚Çú', e‚Çõ' ‚äè e‚Çõ ‚Üí tmc_dir_spec e‚Çõ' e‚Çú') ‚Üí
        (‚àÄ dst idx e‚Çõ' e‚Çú', e‚Çõ' ‚äè e‚Çõ ‚Üí tmc_dps_spec dst idx e‚Çõ' e‚Çú') ‚Üí
        ‚àÄ dst' idx',
        dst = dst' ‚Üí
        idx = idx' ‚Üí
        tmc_dps_spec' dst' idx' e‚Çõ e‚Çú
      )
    ). {
      rewrite /tmc_spec /tmc_dir_spec /tmc_dps_spec.
      naive_solver.
    }
    clear e‚Çõ IHe‚Çõ. apply tmc_ind;
      rewrite /tmc_dir_spec' /tmc_dps_spec';
      intros *;
      [ intros _ _
      | intros _ _
      | intros Hdir1 _ Hdir2 _ IHdir‚Çõ _
      | intros Hdir1 _ Hdir2 _ IHdir‚Çõ _
      | intros Hdir _ IHdir‚Çõ _
      | intros Hdir1 _ Hdir2 _ IHdir‚Çõ _
      | intros Hdir0 _ Hdir1 _ Hdir2 _ IHdir‚Çõ _
      | intros Hdir1 _ Hdir2 _ IHdir‚Çõ _
      | intros Hdir1 _ Hdps2 _ IHdir‚Çõ IHdps‚Çõ
      | intros Hdir1 _ Hdps2 _ IHdir‚Çõ IHdps‚Çõ
      | intros _ _ _ _ _ _
      | intros Hdir1 _ Hdir2 _ IHdir‚Çõ _
      | intros Hdir1 _ Hdir2 _ Hdir3 _ IHdir‚Çõ _
      | intros Hdir IHdir IHdir‚Çõ IHdps‚Çõ dst' idx' -> ->
      | intros Hdir1 _ Hdps2 _ IHdir‚Çõ IHdps‚Çõ dst' idx' -> ->
      | intros Hfunc Hdir _ -> IHdir‚Çõ _ dst' idx' -> ->
      | intros Hdir0 _ Hdps1 _ Hdps2 _ IHdir‚Çõ IHdps‚Çõ dst' idx' -> ->
      | intros Hdir1 _ Hdps2 _ -> IHdir‚Çõ IHdps‚Çõ dst' idx' -> ->
      | intros Hdir2 _ Hdps1 _ -> IHdir‚Çõ IHdps‚Çõ dst' idx' -> ->
      ];
      iIntros "%Hwf %Œ¶ Hpre HŒ¶".
    (* tmc_dir *)
    - iApply csimv_val; auto with tmc_lang.
    - iApply csimv_var. done.
    - iApply csimv_let; iApply IHdir‚Çõ; auto with tmc_lang.
    - iApply csimv_call; [iApply IHdir‚Çõ; auto with tmc_lang.. |].
      iIntros "%func %v‚Çõ %v‚Çú %Hfunc #Hv".
      pose Œ® := sim_post_val tmc_dir_post.
      iApply (simv_apply_protocol _ Œ®). iIntros "%œÉ‚Çõ %œÉ‚Çú $". iSplitR.
      { iLeft. iExists func, v‚Çõ, v‚Çú. iFrame "#‚àó". do 2 (iSplitR; first done).
        iIntros "!> %v‚Çõ' %v‚Çú' #Hv'". iExists v‚Çõ', v‚Çú'. auto.
      }
      iIntros "!> % % (%v‚Çõ' & %v‚Çú' & (-> & ->) & HŒ®)".
      sim_post. iApply ("HŒ¶" with "HŒ®").
    - iApply csimv_unop; [iApply IHdir‚Çõ; auto with tmc_lang | auto].
    - iApply csimv_binop; [iApply IHdir‚Çõ; auto with tmc_lang.. | auto].
    - iApply csimv_if; last iSplit; iApply IHdir‚Çõ; auto with tmc_lang.
    - iApply csimv_constr; [iApply IHdir‚Çõ; auto with tmc_lang.. | auto].
    - iIntros "%Œì % % (-> & ->) #HŒì /=".
      sim_constr‚Çõ1.
      sim_apply simv_constr_val‚Çú1; first (iApply (IHdir‚Çõ e‚Çõ1); auto with tmc_lang).
      iIntros "%v‚Çõ1 %l‚Çú %v‚Çú1 Hl‚Çú0 Hl‚Çú1 Hl‚Çú2 #Hv1".
      sim_smart_apply (IHdps‚Çõ l‚Çú ùüö e‚Çõ2 e‚Çú2.[#l‚Çú/] with "Hl‚Çú2 [Hl‚Çú0 Hl‚Çú1 HŒ¶]"); first 4 last.
      { autosubst. }
      { auto with tmc_lang. }
      { eapply tmc_dps_subst; eauto; autosubst. }
      { auto with tmc_lang. }
      iIntros "%v‚Çõ2 % (%v‚Çú2 & -> & Hl‚Çú2 & #Hv2)".
      sim_constr_det‚Çõ as l‚Çõ "Hl‚Çõ0" "Hl‚Çõ1" "Hl‚Çõ2".
      iDestruct (sim_heap_bij_tie_eq_2 with "Hl‚Çõ0 Hl‚Çú0 [//]") as "Hl0".
      sim_heap_bij_insert.
      iDestruct (sim_heap_bij_tie_eq_2 with "Hl‚Çõ1 Hl‚Çú1 [//]") as "Hl1".
      sim_heap_bij_insert.
      iDestruct (sim_heap_bij_tie_eq_2 with "Hl‚Çõ2 Hl‚Çú2 [//]") as "Hl2".
      sim_heap_bij_insert.
      iApply "HŒ¶". iFrame "#‚àó". done.
    - iIntros "%Œì % % (-> & ->) #HŒì /=".
      sim_constr‚Çõ2.
      sim_apply simv_constr_val‚Çú2; first (iApply (IHdir‚Çõ e‚Çõ2); auto with tmc_lang).
      iIntros "%v‚Çõ2 %l‚Çú %v‚Çú2 Hl‚Çú0 Hl‚Çú1 Hl‚Çú2 #Hv2".
      sim_smart_apply (IHdps‚Çõ l‚Çú ùüô e‚Çõ1 e‚Çú1.[#l‚Çú/] with "Hl‚Çú1 [Hl‚Çú0 Hl‚Çú2 HŒ¶]"); first 4 last.
      { autosubst. }
      { auto with tmc_lang. }
      { eapply tmc_dps_subst; eauto; autosubst. }
      { auto with tmc_lang. }
      iIntros "%v‚Çõ1 % (%v‚Çú1 & -> & Hl‚Çú1 & #Hv1)".
      sim_constr_det‚Çõ as l‚Çõ "Hl‚Çõ0" "Hl‚Çõ1" "Hl‚Çõ2".
      iDestruct (sim_heap_bij_tie_eq_2 with "Hl‚Çõ0 Hl‚Çú0 [//]") as "Hl0".
      sim_heap_bij_insert.
      iDestruct (sim_heap_bij_tie_eq_2 with "Hl‚Çõ1 Hl‚Çú1 [//]") as "Hl1".
      sim_heap_bij_insert.
      iDestruct (sim_heap_bij_tie_eq_2 with "Hl‚Çõ2 Hl‚Çú2 [//]") as "Hl2".
      sim_heap_bij_insert.
      iApply "HŒ¶". iFrame "#‚àó". done.
    - auto with tmc_lang.
    - iApply csimv_load; [iApply IHdir‚Çõ; auto with tmc_lang.. | auto].
    - iApply csimv_store; [iApply IHdir‚Çõ; auto with tmc_lang.. |].
      iApply "HŒ¶". done.
    (* tmc_dps *)
    - iIntros "%Œì % % (-> & ->) #HŒì". sim_simpl.
      sim_apply (IHdir with "[//] [Hpre HŒ¶]"); [done.. |]. iIntros "%v‚Çõ %v‚Çú #Hv".
      sim_store‚Çú.
      iApply "HŒ¶". iExists v‚Çú. iFrame "#‚àó". done.
    - iApply csimv_let.
      { iApply (IHdir‚Çõ with "[//] []"); auto with tmc_lang. }
      iApply (IHdps‚Çõ with "Hpre [HŒ¶]"); [auto with tmc_lang.. |]. iIntros "%v‚Çõ % (%v‚Çú & -> & Hdst' & #Hv)".
      iApply "HŒ¶". iExists v‚Çú. auto with iFrame.
    - iIntros "%Œì % % (-> & ->) #HŒì". sim_simpl.
      sim_apply (IHdir‚Çõ with "[//] [Hpre HŒ¶] [//] HŒì"); [auto with tmc_lang.. | ]. iIntros "%v‚Çõ %v‚Çú #Hv".
      sim_smart_apply (tmc_protocol_dps' with "Hpre Hv"); [auto with tmc_lang.. |]. iIntros "%v‚Çõ' %v‚Çú' Hdst' #Hv'".
      iApply "HŒ¶". iExists v‚Çú'. auto with iFrame.
    - iApply csimv_if.
      { iApply (IHdir‚Çõ with "[//] []"); auto with tmc_lang. }
      iSplit;
        iApply (IHdps‚Çõ with "Hpre [HŒ¶]"); [auto with tmc_lang.. |]; iIntros "%v‚Çõ % (%v‚Çú & -> & Hdst' & #Hv)";
        iApply "HŒ¶"; iExists v‚Çú; auto with iFrame.
    - iIntros "%Œì % % (-> & ->) #HŒì". sim_simpl.
      sim_constr‚Çõ1.
      sim_apply simv_constr_val‚Çú1.
      { sim_apply (IHdir‚Çõ with "[//] [] [//] HŒì"); auto with tmc_lang. }
      iIntros "%v‚Çõ1 %l‚Çú %v‚Çú1 Hl‚Çú0 Hl‚Çú1 Hl‚Çú2 #Hv1".
      sim_store‚Çú.
      sim_smart_apply (IHdps‚Çõ l‚Çú ùüö e‚Çõ2 e‚Çú2.[#l‚Çú/] with "Hl‚Çú2 [Hpre Hl‚Çú0 Hl‚Çú1 HŒ¶] [] HŒì"); first 4 last.
      { autosubst. }
      { auto with tmc_lang. }
      { eapply tmc_dps_subst; eauto; autosubst. }
      { auto with tmc_lang. }
      iIntros "%v‚Çõ2 % (%v‚Çú2 & -> & Hl‚Çú2 & #Hv2)".
      sim_constr_det‚Çõ as l‚Çõ "Hl‚Çõ0" "Hl‚Çõ1" "Hl‚Çõ2".
      iDestruct (sim_heap_bij_tie_eq_2 with "Hl‚Çõ0 Hl‚Çú0 [//]") as "Hl0".
      sim_heap_bij_insert.
      iDestruct (sim_heap_bij_tie_eq_2 with "Hl‚Çõ1 Hl‚Çú1 [//]") as "Hl1".
      sim_heap_bij_insert.
      iDestruct (sim_heap_bij_tie_eq_2 with "Hl‚Çõ2 Hl‚Çú2 [//]") as "Hl2".
      sim_heap_bij_insert.
      iApply "HŒ¶". iExists l‚Çú. iFrame. iSplitR; first done. iFrame "#‚àó". done.
    - iIntros "%Œì % % (-> & ->) #HŒì". sim_simpl.
      sim_constr‚Çõ2.
      sim_apply simv_constr_val‚Çú2.
      { sim_apply (IHdir‚Çõ with "[//] [] [//] HŒì"); auto with tmc_lang. }
      iIntros "%v‚Çõ2 %l‚Çú %v‚Çú2 Hl‚Çú0 Hl‚Çú1 Hl‚Çú2 #Hv2".
      sim_store‚Çú.
      sim_smart_apply (IHdps‚Çõ l‚Çú ùüô e‚Çõ1 e‚Çú1.[#l‚Çú/] with "Hl‚Çú1 [Hpre Hl‚Çú0 Hl‚Çú2 HŒ¶] [] HŒì"); first 4 last.
      { autosubst. }
      { auto with tmc_lang. }
      { eapply tmc_dps_subst; eauto; autosubst. }
      { auto with tmc_lang. }
      iIntros "%v‚Çõ1 % (%v‚Çú1 & -> & Hl‚Çú1 & #Hv1)".
      sim_constr_det‚Çõ as l‚Çõ "Hl‚Çõ0" "Hl‚Çõ1" "Hl‚Çõ2".
      iDestruct (sim_heap_bij_tie_eq_2 with "Hl‚Çõ0 Hl‚Çú0 [//]") as "Hl0".
      sim_heap_bij_insert.
      iDestruct (sim_heap_bij_tie_eq_2 with "Hl‚Çõ1 Hl‚Çú1 [//]") as "Hl1".
      sim_heap_bij_insert.
      iDestruct (sim_heap_bij_tie_eq_2 with "Hl‚Çõ2 Hl‚Çú2 [//]") as "Hl2".
      sim_heap_bij_insert.
      iApply "HŒ¶". iExists l‚Çú. iFrame. iSplitR; first done. iFrame "#‚àó". done.
  Qed.
  Lemma tmc_dir_specification e‚Çõ e‚Çú :
    tmc_dir_spec e‚Çõ e‚Çú.
  Proof.
    eapply proj1, tmc_specification.
  Qed.
  Lemma tmc_dps_specification dst idx e‚Çõ e‚Çú :
    tmc_dps_spec dst idx e‚Çõ e‚Çú.
  Proof.
    revert dst idx. eapply proj2, tmc_specification.
  Qed.

  Lemma tmc_simv_close e‚Çõ e‚Çú Œ¶ :
    program_valid sim_prog‚Çõ ‚Üí
    SIM e‚Çõ ‚â≥ e‚Çú [[ tmc_protocol ]] [[ Œ¶ ]] -‚àó
    SIM e‚Çõ ‚â≥ e‚Çú [[ Œ¶ ]].
  Proof.
    intros (Hprog‚Çõ_wf & Hprog‚Çõ_closed).
    eapply program_closed_tmc in Hprog‚Çõ_closed as Hprog‚Çú_closed; last done.
    iApply simv_close_pure_head_step. clear e‚Çõ e‚Çú. iIntros "!> %Œ® %e‚Çõ %e‚Çú [Hprotocol | Hprotocol]".
    - iDestruct "Hprotocol" as "(%func & %v‚Çõ & %v‚Çú & %Hfunc‚Çõ & (-> & ->) & #Hv & HŒ®)".
      simpl in Hfunc‚Çõ. apply lookup_lookup_total_dom in Hfunc‚Çõ. set (e‚Çõ := _ !!! _) in Hfunc‚Çõ.
      edestruct tmc.(tmc_dirs) as (e‚Çú & Hdir & Hfunc‚Çú); first done.
      iExists e‚Çõ.[#v‚Çõ/], e‚Çú.[#v‚Çú/]. iSplit; first auto with tmc_lang.
      erewrite (subst_program_closed' ids inhabitant); last done; last done.
      erewrite (subst_program_closed' ids inhabitant); last done; last done.
      iDestruct (tmc_dir_specification $! tmc_dir_post with "[//] [] [//] []") as "Hsim"; eauto.
      + iApply (bisubst_cons_well_formed with "Hv").
        iApply bisubst_inhabitant_well_formed.
      + rewrite definition.simv_unseal /definition.simv_def.
        rewrite -bisubst_cons‚Çõ -bisubst_cons‚Çú.
        sim_mono "Hsim". iIntros "% % (%v‚Çõ' & %v‚Çú' & (-> & ->) & #Hv')".
        iApply ("HŒ®" with "Hv'").
    - iDestruct "Hprotocol" as "(%func & %func_dps & %v‚Çõ & %l1 & %l2 & %dst & %idx & %v‚Çú & (%Hfunc‚Çõ & %HŒæ) & (-> & ->) & Hl11 & Hl12 & Hl21 & Hl22 & Hdst & #Hv & HŒ®)".
      simpl in Hfunc‚Çõ. apply lookup_lookup_total_dom in Hfunc‚Çõ. set (e‚Çõ := _ !!! _) in Hfunc‚Çõ.
      edestruct tmc.(tmc_dpss) as (e‚Çú & Hdps & Hfunc_dps‚Çú); [done.. |].
      iExists e‚Çõ.[#v‚Çõ/], _. iSplit; first auto with tmc_lang.
      do 4 sim_load‚Çú. sim_pures.
      eapply (tmc_dps_subst _ (ids 0 .: #dst .: #idx .: ren (+1))) in Hdps; [| autosubst..].
      erewrite (subst_program_closed' _ (ren (+1))) in Hdps; last done; last done. asimpl in Hdps.
      replace e‚Çú.[#v‚Çú, #dst, #idx, #l2, #l1/] with e‚Çú.[ids 0 .: #dst .: #idx .: ren (+1)].[#v‚Çú, #l2, #l1/] by autosubst.
      erewrite (subst_program_closed' ids inhabitant); last done; last done.
      erewrite (subst_expr_closed_1' (#l2 .: #l1 .: ids) inhabitant); last first.
      { eapply expr_closed_tmc_dps; naive_solver. }
      iDestruct (tmc_dps_specification $! (tmc_dps_post dst idx) with "Hdst [] [//] []") as "Hsim"; eauto.
      + iApply (bisubst_cons_well_formed with "Hv").
        iApply bisubst_inhabitant_well_formed.
      + rewrite definition.simv_unseal /definition.simv_def.
        rewrite -bisubst_cons‚Çõ -bisubst_cons‚Çú.
        sim_mono "Hsim". iIntros "% % (%v‚Çõ' & % & (-> & ->) & %v‚Çú' & -> & Hdst & #Hv')".
        iApply ("HŒ®" with "Hdst Hv'").
  Qed.
End sim_GS.

Section tmc_sound.
  Context {prog‚Çõ prog‚Çú : program}.
  Context (Hwf : program_valid prog‚Çõ).
  Context (tmc : tmc prog‚Çõ prog‚Çú).

  Notation Œ£ := sim_Œ£.
  Notation M := (iResUR Œ£).

  #[local] Instance tmc_sim_programs : SimPrograms tmc_ectx_lang tmc_ectx_lang :=
    Build_SimPrograms prog‚Çõ prog‚Çú.

  #[local] Instance tmc_sim_GpreS :
    SimGpreS Œ£.
  Proof.
    apply subG_sim_GpreS, subG_refl.
  Qed.

  Lemma tmc_sound :
    program_refinement prog‚Çõ prog‚Çú.
  Proof.
    rewrite /program_refinement map_Forall_lookup => func e‚Çõ Hfunc‚Çõ v‚Çõ v‚Çú Hv‚Çõ Hv.
    pose proof (simv_adequacy' (M := M)) as Hadequacy. apply Hadequacy.
    iMod (sim_init ‚àÖ ‚àÖ) as "(%sim_GS & Hsi & _ & _ & _ & _)".
    iModIntro. iExists _, _. iFrame. iSplitR.
    { clear dependent v‚Çõ v‚Çú. iIntros "!> %v‚Çõ %v‚Çú #Hv".
      iApply (val_bi_similar_similar with "Hv").
    }
    iApply (tmc_simv_close (sim_programs := tmc_sim_programs) tmc); first done.
    iApply (simv_apply_protocol _ (sim_post_val (‚âà)%I)). iIntros "%œÉ‚Çõ %œÉ‚Çú $ !>".
    iSplitL.
    - iLeft. iExists func, v‚Çõ, v‚Çú. repeat iSplit; try done.
      + iPureIntro. simpl. eapply elem_of_dom_2. done.
      + iApply val_similar_bi_similar; done.
      + iIntros "%v‚Çõ' %v‚Çú' #Hv'". iExists v‚Çõ', v‚Çú'. auto with iFrame.
    - clear dependent v‚Çõ e‚Çõ v‚Çú. iIntros "%e‚Çõ %e‚Çú (%v‚Çõ & %v‚Çú & (-> & ->) & #Hv)".
      sim_post.
  Qed.
End tmc_sound.
